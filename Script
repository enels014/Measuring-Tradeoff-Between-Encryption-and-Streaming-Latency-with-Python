import cv2
import pandas as pd
import numpy as np
import time
import os
import matplotlib.pyplot as plt
import csv
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from tqdm import tqdm
import random

# -----------------------------
# PARAMETERS
# -----------------------------
video_path = 'drone_video.mp4'       # Input video file
output_csv = 'latency_results.csv'   # CSV output for metrics
fps = 30                              # Frames per second
frame_limit = 100                     # Limit for faster testing
base_latency_ms = 50                  # Base network latency (ms)
jitter_std_ms = 5                     # Standard deviation for latency jitter
packet_loss_prob = 0.05               # 5% chance of packet loss per frame
snr_db = 10                            # SNR for noise in Rayleigh channel

# Encryption schemes
encryption_schemes = {
    'AES-256': 32,
    'AES-128': 16,
    'ChaCha20': 32
}

# -----------------------------
# HELPER FUNCTIONS
# -----------------------------
def pad_frame(frame_bytes):
    """Pad frame bytes to a multiple of 16 for AES encryption."""
    padding_len = 16 - (len(frame_bytes) % 16)
    return frame_bytes + bytes([padding_len]) * padding_len

def unpad_frame(frame_bytes):
    """Remove AES padding."""
    padding_len = frame_bytes[-1]
    return frame_bytes[:-padding_len]

# AES encryption/decryption
def encrypt_aes(frame_bytes, key):
    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(frame_bytes) + encryptor.finalize()
    return ciphertext, iv

def decrypt_aes(ciphertext, key, iv):
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    return decryptor.update(ciphertext) + decryptor.finalize()

# ChaCha20 encryption/decryption
def encrypt_chacha(frame_bytes, key):
    nonce = os.urandom(16)
    cipher = Cipher(algorithms.ChaCha20(key, nonce), mode=None, backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(frame_bytes)
    return ciphertext, nonce

def decrypt_chacha(ciphertext, key, nonce):
    cipher = Cipher(algorithms.ChaCha20(key, nonce), mode=None, backend=default_backend())
    decryptor = cipher.decryptor()
    return decryptor.update(ciphertext)

# -----------------------------
# NETWORK LATENCY SIMULATION
# -----------------------------
def adjusted_network_latency(frame_num, channel_gains, base_latency_ms=50, jitter_std_ms=5):
    """
    Compute simulated network latency for a frame.
    Weaker channel gain â†’ higher latency. Adds Gaussian jitter.
    """
    if frame_num-1 >= len(channel_gains):
        gain = channel_gains[-1]
    else:
        gain = channel_gains[frame_num-1]

    gain = max(gain, 0.01)  # Avoid division by zero
    latency_ms = base_latency_ms / gain
    jitter = np.random.normal(0, jitter_std_ms)
    latency_ms = max(latency_ms + jitter, 0.5)  # Minimum latency 0.5ms
    time.sleep(latency_ms / 1000.0)
    return latency_ms, gain

# -----------------------------
# RAYLEIGH CHANNEL WITH NOISE
# -----------------------------
def rayleigh_channel(frame_bytes, snr_db=10):
    """
    Simulate Rayleigh fading plus additive Gaussian noise.
    Multiplicative fading (abs(h)) and AWGN based on SNR.
    """
    arr = np.frombuffer(frame_bytes, dtype=np.uint8).astype(np.float32)
    # Generate complex Rayleigh fading coefficients
    h = np.sqrt(0.5) * (np.random.randn(*arr.shape) + 1j * np.random.randn(*arr.shape))
    faded = arr * np.abs(h)  # Apply fading

    # Compute noise power for desired SNR
    signal_power = np.mean(faded**2)
    noise_power = signal_power / (10**(snr_db / 10))
    noise = np.random.normal(0, np.sqrt(noise_power), faded.shape)

    rx = faded + noise  # Additive noise
    rx = np.clip(rx, 0, 255)
    return rx.astype(np.uint8).tobytes()

# -----------------------------
# MAIN SIMULATION
# -----------------------------
cap = cv2.VideoCapture(video_path)
if not cap.isOpened():
    raise Exception(f"Cannot open video: {video_path}")

total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
if frame_limit:
    total_frames = min(total_frames, frame_limit)

# Initialize CSV logging
with open(output_csv, 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(['Scheme','Frame','Encrypt(ms)','Decrypt(ms)','End-to-End(ms)','ChannelType','Dropped'])

# Simulate channel gains for latency
channel_gains = np.random.uniform(0.1, 1.0, total_frames)

print(f"\nProcessing {total_frames} frames...\n")

frame_num = 0
for _ in tqdm(range(total_frames), desc="Frames"):
    ret, frame = cap.read()
    if not ret:
        break
    frame_num += 1

    # Encode frame as JPEG bytes and pad for encryption
    frame_bytes = cv2.imencode('.jpg', frame, [int(cv2.IMWRITE_JPEG_QUALITY), 90])[1].tobytes()
    frame_bytes = pad_frame(frame_bytes)

    for scheme, key_len in encryption_schemes.items():
        key = os.urandom(key_len)
        dropped = random.random() < packet_loss_prob

        if dropped:
            # Frame is dropped, only apply network latency
            net_latency, _ = adjusted_network_latency(frame_num, channel_gains)
            t_encrypt = t_decrypt = total_latency = 0
            channel_type = 'Dropped'
        else:
            # Encrypt frame
            t_start = time.time()
            if scheme.startswith("AES"):
                ciphertext, iv = encrypt_aes(frame_bytes, key)
            else:
                ciphertext, nonce = encrypt_chacha(frame_bytes, key)
            t_encrypt = (time.time() - t_start) * 1000

            # Apply Rayleigh fading + noise
            channel_type = 'Rayleigh'
            channeled_bytes = rayleigh_channel(ciphertext, snr_db)

            # Network latency
            net_latency, _ = adjusted_network_latency(frame_num, channel_gains)

            # Decrypt frame
            t_start = time.time()
            if scheme.startswith("AES"):
                decrypted_bytes = decrypt_aes(channeled_bytes, key, iv)
            else:
                decrypted_bytes = decrypt_chacha(channeled_bytes, key, nonce)
            t_decrypt = (time.time() - t_start) * 1000

            total_latency = t_encrypt + t_decrypt + net_latency

        # Log results to CSV
        with open(output_csv, 'a', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([scheme, frame_num, round(t_encrypt,2), round(t_decrypt,2),
                             round(total_latency,2), channel_type, dropped])

cap.release()

# -----------------------------
# ANALYSIS AND PLOTTING
# -----------------------------
df = pd.read_csv(output_csv)

print("\n=== AVERAGE LATENCIES PER SCHEME (ms) ===")
for scheme in encryption_schemes:
    df_scheme = df[(df['Scheme']==scheme) & (~df['Dropped'])]
    avg_encrypt = df_scheme['Encrypt(ms)'].mean()
    avg_decrypt = df_scheme['Decrypt(ms)'].mean()
    avg_total = df_scheme['End-to-End(ms)'].mean()
    drop_rate = df[df['Scheme']==scheme]['Dropped'].mean()*100
    print(f"{scheme}: Encrypt={avg_encrypt:.2f}, Decrypt={avg_decrypt:.2f}, "
          f"End-to-End={avg_total:.2f}, Packet Loss={drop_rate:.1f}%")

# Scatter plot of latency per frame
plt.figure(figsize=(14,6))
for scheme in encryption_schemes:
    df_scheme = df[df['Scheme']==scheme]
    plt.scatter(df_scheme['Frame'], df_scheme['End-to-End(ms)'],
                c='red', s=10, alpha=0.5, label=scheme)
plt.xlabel('Frame Number')
plt.ylabel('End-to-End Latency (ms)')
plt.title('Video Encryption End-to-End Latency (Rayleigh Fading + Noise)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()


